#include "rkomsupport.h"
/* Generated by spcgen, do not edit */

#include <sys/types.h>
#include <sys/uio.h>
#include <errno.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifndef USE_E_ERR
#include <err.h>
#endif
#include <assert.h>

#ifdef USE_E_ERR
#include "e_err.h"
#endif
#include "rkom_proto.h"
#ifdef DMALLOC
#include <dmalloc.h>
#endif
#ifdef MEMDEBUG
#include <memdebug.h>
#endif


/*
 * Round up 'a' to next multiple of 'size'
 */
#define ROUNDUP(a, size) (((a) & ((size)-1)) ? (1 + ((a) | ((size)-1))) : (a))


/* Begin verbatim code */


/* End verbatim code */


static int spc_read_fd, spc_write_fd;

ssize_t spc_myread(int, void *, size_t);
ssize_t spc_mywritev(int, struct iovec *, int);

void
spc_set_write_fd(int fd)
{
	spc_write_fd = fd;
}

void
spc_set_read_fd(int fd)
{
	spc_read_fd = fd;
}

int
spc_get_write_fd(void)
{
	return spc_write_fd;
}

int
spc_get_read_fd(void)
{
	return spc_read_fd;
}


/* from Stevens UNPV1 */
ssize_t
spc_myread(int fd, void *vptr, size_t n)
{
	size_t	nleft;
	ssize_t	nread;
	char	*ptr;

	ptr = vptr;
	nleft = n;
	while (nleft > 0) {
		if ((nread = read(fd, ptr, nleft)) < 0) {
			if (errno == EINTR)
				continue;		/* and call read() again */
			return -1;
		} else if (nread == 0)
			break;				/* EOF */

		nleft -= nread;
		ptr += nread;
	}
	return (n - nleft);
}


ssize_t
spc_mywritev(int fd, struct iovec *in_iov, int iovcnt)
{
	struct	iovec *iov;
	size_t	nleft;
	ssize_t	nwritten, n;
	int		i;
	

	/* copy in_iov to our own struct to allow us to modify it later */
	if ((iov = alloca(sizeof(struct iovec) * iovcnt)) == NULL)
		err(1, "alloca");
	memcpy(iov, in_iov, sizeof(struct iovec) * iovcnt);

	n = 0;
	for (i = 0; i < iovcnt; i++)
		n += iov[i].iov_len;
		
	nleft = n;
	nwritten = 0;
	while (nleft > 0) {
		/* advance in iov array */
		while (nwritten >= iov->iov_len && nwritten > 0) {
			nwritten -= iov->iov_len;
			iov++;				/* this iov is written */
			iovcnt--;
			assert(iovcnt != 0);
		}
		/* update offset in the first iov */
		iov->iov_base = (char *)iov->iov_base + nwritten;
		iov->iov_len -= nwritten;

		if ((nwritten = writev(fd, iov, iovcnt)) <= 0) {
			if (errno == EINTR) {
				nwritten = 0;
				continue;		/* and call writev() again */
			}
			return -1;
		}
		nleft -= nwritten;
	}
	return n;
}


void
spc_read_msg(void *buf, size_t nbytes)
{
	ssize_t	res;

	if ((res = spc_myread(spc_read_fd, buf, nbytes)) != nbytes) {
		if (res == 0)
			errx(1, "other end closed connection, shutting down.");
		err(1, "read");
	}
}


u_int32_t
spc_read_msglen(void)
{
	u_int32_t	msglen;

	spc_read_msg(&msglen, sizeof(msglen));
	return msglen;
}


u_int32_t
spc_read_fun_num(void)
{
	u_int32_t	fun_num;

	spc_read_msg(&fun_num, sizeof(fun_num));
	return fun_num;
}


void
spc_write_msg(void *buf, size_t nbytes)
{
	struct iovec iov[2];
	u_int32_t	msglen;

	msglen = nbytes;
	iov[0].iov_base = (void *)&msglen;
	iov[0].iov_len = sizeof(msglen);
	iov[1].iov_base = buf;
	iov[1].iov_len = nbytes;

	if (spc_mywritev(spc_write_fd, iov, 2) != nbytes + sizeof(msglen))
		err(1, "writev");
}


void
spc_write_fun_call(u_int32_t fun_num, void *buf, size_t nbytes)
{
	struct iovec iov[3];
	u_int32_t	msglen;
	size_t		len;

	msglen = nbytes + sizeof(fun_num);
	iov[0].iov_base = (void *)&msglen;
	iov[0].iov_len = sizeof(msglen);
	iov[1].iov_base = (void *)&fun_num;
	iov[1].iov_len = sizeof(fun_num);
	iov[2].iov_base = buf;
	iov[2].iov_len = nbytes;
	len = nbytes + sizeof(msglen) + sizeof(fun_num);

	if (spc_mywritev(spc_write_fd, iov, 3) != len)
		err(1, "writev");
}



/* Implementation of get_size_encoded_XXX functions */

size_t
get_size_encoded_string(char ** var)
{
	return strlen(*var) + 1;
}

size_t
get_size_encoded_int8_t(int8_t* var)
{
	return sizeof(*var);
}

size_t
get_size_encoded_u_int8_t(u_int8_t* var)
{
	return sizeof(*var);
}

size_t
get_size_encoded_int16_t(int16_t* var)
{
	return sizeof(*var);
}

size_t
get_size_encoded_u_int16_t(u_int16_t* var)
{
	return sizeof(*var);
}

size_t
get_size_encoded_int32_t(int32_t* var)
{
	return sizeof(*var);
}

size_t
get_size_encoded_u_int32_t(u_int32_t* var)
{
	return sizeof(*var);
}

size_t
get_size_encoded_int64_t(int64_t* var)
{
	return sizeof(*var);
}

size_t
get_size_encoded_u_int64_t(u_int64_t* var)
{
	return sizeof(*var);
}

size_t
get_size_encoded_float(float* var)
{
	return sizeof(*var);
}

size_t
get_size_encoded_double(double* var)
{
	return sizeof(*var);
}

size_t
get_size_encoded_rk_time(struct rk_time* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_u_int8_t(&var->rt_seconds);

	len += get_size_encoded_u_int8_t(&var->rt_minutes);

	len += get_size_encoded_u_int8_t(&var->rt_hours);

	len += get_size_encoded_u_int8_t(&var->rt_day);

	len += get_size_encoded_u_int8_t(&var->rt_month);

	len += get_size_encoded_u_int16_t(&var->rt_year);

	len += get_size_encoded_u_int8_t(&var->rt_day_of_week);

	len += get_size_encoded_u_int16_t(&var->rt_day_of_year);

	len += get_size_encoded_u_int8_t(&var->rt_is_dst);

	return len;
}

size_t
get_size_encoded_rk_misc_info(struct rk_misc_info* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_u_int32_t(&var->rmi_type);

	len += get_size_encoded_u_int32_t(&var->rmi_numeric);

	len += get_size_encoded_rk_time(&var->rmi_time);

	return len;
}

size_t
get_size_encoded_rk_aux_item(struct rk_aux_item* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_u_int32_t(&var->rai_aux_no);

	len += get_size_encoded_u_int32_t(&var->rai_tag);

	len += get_size_encoded_u_int32_t(&var->rai_creator);

	len += get_size_encoded_rk_time(&var->rai_created_at);

	len += get_size_encoded_u_int32_t(&var->rai_flags);

	len += get_size_encoded_u_int32_t(&var->inherit_limit);

	len += get_size_encoded_string(&var->rai_data);

	return len;
}

size_t
get_size_encoded_rk_aux_item_input(struct rk_aux_item_input* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_u_int32_t(&var->raii_tag);

	len += get_size_encoded_u_int32_t(&var->raii_flags);

	len += get_size_encoded_u_int32_t(&var->inherit_limit);

	len += get_size_encoded_string(&var->raii_data);

	return len;
}

size_t
get_size_encoded_rk_text_stat(struct rk_text_stat* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_int32_t(&var->rt_retval);

	len += get_size_encoded_rk_time(&var->rt_time);

	len += get_size_encoded_u_int32_t(&var->rt_author);

	len += get_size_encoded_u_int32_t(&var->rt_no_of_lines);

	len += get_size_encoded_u_int32_t(&var->rt_no_of_chars);

	len += get_size_encoded_u_int32_t(&var->rt_no_of_marks);

	len += sizeof(var->rt_misc_info.rt_misc_info_len);
	for (i = 0; i < var->rt_misc_info.rt_misc_info_len; i++)
		len += get_size_encoded_rk_misc_info(&var->rt_misc_info.rt_misc_info_val[i]);

	len += sizeof(var->rt_aux_item.rt_aux_item_len);
	for (i = 0; i < var->rt_aux_item.rt_aux_item_len; i++)
		len += get_size_encoded_rk_aux_item(&var->rt_aux_item.rt_aux_item_val[i]);

	return len;
}

size_t
get_size_encoded_rk_membership(struct rk_membership* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_int32_t(&var->rm_retval);

	len += get_size_encoded_u_int32_t(&var->rm_position);

	len += get_size_encoded_rk_time(&var->rm_last_time_read);

	len += get_size_encoded_u_int32_t(&var->rm_conference);

	len += get_size_encoded_u_int32_t(&var->rm_priority);

	len += get_size_encoded_u_int32_t(&var->rm_last_text_read);

	len += sizeof(var->rm_read_texts.rm_read_texts_len);
	for (i = 0; i < var->rm_read_texts.rm_read_texts_len; i++)
		len += get_size_encoded_u_int32_t(&var->rm_read_texts.rm_read_texts_val[i]);

	len += get_size_encoded_u_int32_t(&var->rm_added_by);

	len += get_size_encoded_rk_time(&var->rm_added_at);

	len += get_size_encoded_u_int32_t(&var->rm_type);

	return len;
}

size_t
get_size_encoded_rk_conference(struct rk_conference* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_int32_t(&var->rc_retval);

	len += get_size_encoded_string(&var->rc_name);

	len += get_size_encoded_u_int32_t(&var->rc_type);

	len += get_size_encoded_rk_time(&var->rc_creation_time);

	len += get_size_encoded_rk_time(&var->rc_last_written);

	len += get_size_encoded_u_int32_t(&var->rc_creator);

	len += get_size_encoded_u_int32_t(&var->rc_presentation);

	len += get_size_encoded_u_int32_t(&var->rc_supervisor);

	len += get_size_encoded_u_int32_t(&var->rc_permitted_submitters);

	len += get_size_encoded_u_int32_t(&var->rc_super_conf);

	len += get_size_encoded_u_int32_t(&var->rc_msg_of_day);

	len += get_size_encoded_u_int32_t(&var->rc_nice);

	len += get_size_encoded_u_int32_t(&var->rc_keep_commented);

	len += get_size_encoded_u_int32_t(&var->rc_no_of_members);

	len += get_size_encoded_u_int32_t(&var->rc_first_local_no);

	len += get_size_encoded_u_int32_t(&var->rc_no_of_texts);

	len += get_size_encoded_u_int32_t(&var->rc_expire);

	len += sizeof(var->rc_aux_item.rc_aux_item_len);
	for (i = 0; i < var->rc_aux_item.rc_aux_item_len; i++)
		len += get_size_encoded_rk_aux_item(&var->rc_aux_item.rc_aux_item_val[i]);

	return len;
}

size_t
get_size_encoded_rk_uconference(struct rk_uconference* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_int32_t(&var->ru_retval);

	len += get_size_encoded_string(&var->ru_name);

	len += get_size_encoded_u_int32_t(&var->ru_type);

	len += get_size_encoded_u_int32_t(&var->ru_highest_local_no);

	len += get_size_encoded_u_int32_t(&var->ru_nice);

	return len;
}

size_t
get_size_encoded_rk_person(struct rk_person* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_int32_t(&var->rp_retval);

	len += get_size_encoded_string(&var->rp_username);

	len += get_size_encoded_u_int32_t(&var->rp_privileges);

	len += get_size_encoded_u_int32_t(&var->rp_flags);

	len += get_size_encoded_rk_time(&var->rp_last_login);

	len += get_size_encoded_u_int32_t(&var->rp_user_area);

	len += get_size_encoded_u_int32_t(&var->rp_total_time_present);

	len += get_size_encoded_u_int32_t(&var->rp_sessions);

	len += get_size_encoded_u_int32_t(&var->rp_created_lines);

	len += get_size_encoded_u_int32_t(&var->rp_created_bytes);

	len += get_size_encoded_u_int32_t(&var->rp_read_texts);

	len += get_size_encoded_u_int32_t(&var->rp_no_of_text_fetches);

	len += get_size_encoded_u_int32_t(&var->rp_created_persons);

	len += get_size_encoded_u_int32_t(&var->rp_created_confs);

	len += get_size_encoded_u_int32_t(&var->rp_first_created_local_no);

	len += get_size_encoded_u_int32_t(&var->rp_no_of_created_texts);

	len += get_size_encoded_u_int32_t(&var->rp_no_of_marks);

	len += get_size_encoded_u_int32_t(&var->rp_no_of_confs);

	return len;
}

size_t
get_size_encoded_rk_confinfo(struct rk_confinfo* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_string(&var->rc_name);

	len += get_size_encoded_u_int32_t(&var->rc_type);

	len += get_size_encoded_u_int32_t(&var->rc_conf_no);

	return len;
}

size_t
get_size_encoded_rk_confinfo_retval(struct rk_confinfo_retval* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += sizeof(var->rcr_ci.rcr_ci_len);
	for (i = 0; i < var->rcr_ci.rcr_ci_len; i++)
		len += get_size_encoded_rk_confinfo(&var->rcr_ci.rcr_ci_val[i]);

	return len;
}

size_t
get_size_encoded_rk_dynamic_session_info(struct rk_dynamic_session_info* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_u_int32_t(&var->rds_session);

	len += get_size_encoded_u_int32_t(&var->rds_person);

	len += get_size_encoded_u_int32_t(&var->rds_conf);

	len += get_size_encoded_u_int32_t(&var->rds_idletime);

	len += get_size_encoded_u_int32_t(&var->rds_flags);

	len += get_size_encoded_string(&var->rds_doing);

	return len;
}

size_t
get_size_encoded_rk_dynamic_session_info_retval(struct rk_dynamic_session_info_retval* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += sizeof(var->rdv_rds.rdv_rds_len);
	for (i = 0; i < var->rdv_rds.rdv_rds_len; i++)
		len += get_size_encoded_rk_dynamic_session_info(&var->rdv_rds.rdv_rds_val[i]);

	return len;
}

size_t
get_size_encoded_rk_unreadconfval(struct rk_unreadconfval* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_int32_t(&var->ru_retval);

	len += sizeof(var->ru_confs.ru_confs_len);
	for (i = 0; i < var->ru_confs.ru_confs_len; i++)
		len += get_size_encoded_u_int32_t(&var->ru_confs.ru_confs_val[i]);

	return len;
}

size_t
get_size_encoded_rk_memberconflist(struct rk_memberconflist* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_int32_t(&var->rm_retval);

	len += sizeof(var->rm_confs.rm_confs_len);
	for (i = 0; i < var->rm_confs.rm_confs_len; i++)
		len += get_size_encoded_u_int32_t(&var->rm_confs.rm_confs_val[i]);

	return len;
}

size_t
get_size_encoded_rk_text_retval(struct rk_text_retval* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_int32_t(&var->rtr_status);

	len += get_size_encoded_u_int32_t(&var->rtr_textnr);

	return len;
}

size_t
get_size_encoded_rk_text_info(struct rk_text_info* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_string(&var->rti_text);

	len += sizeof(var->rti_misc.rti_misc_len);
	for (i = 0; i < var->rti_misc.rti_misc_len; i++)
		len += get_size_encoded_rk_misc_info(&var->rti_misc.rti_misc_val[i]);

	len += sizeof(var->rti_input.rti_input_len);
	for (i = 0; i < var->rti_input.rti_input_len; i++)
		len += get_size_encoded_rk_aux_item_input(&var->rti_input.rti_input_val[i]);

	return len;
}

size_t
get_size_encoded_rk_modifyconfinfo(struct rk_modifyconfinfo* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_u_int32_t(&var->rkm_conf);

	len += sizeof(var->rkm_delete.rkm_delete_len);
	for (i = 0; i < var->rkm_delete.rkm_delete_len; i++)
		len += get_size_encoded_u_int32_t(&var->rkm_delete.rkm_delete_val[i]);

	len += sizeof(var->rkm_add.rkm_add_len);
	for (i = 0; i < var->rkm_add.rkm_add_len; i++)
		len += get_size_encoded_rk_aux_item_input(&var->rkm_add.rkm_add_val[i]);

	return len;
}

size_t
get_size_encoded_rk_async(struct rk_async* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_u_int32_t(&var->ra_type);

	len += get_size_encoded_u_int32_t(&var->ra_conf);

	len += get_size_encoded_u_int32_t(&var->ra_pers);

	len += get_size_encoded_u_int32_t(&var->ra_text);

	len += get_size_encoded_string(&var->ra_message);

	len += get_size_encoded_string(&var->ra_message2);

	return len;
}

size_t
get_size_encoded_rk_marks(struct rk_marks* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_u_int32_t(&var->rm_text);

	len += get_size_encoded_u_int8_t(&var->rm_type);

	return len;
}

size_t
get_size_encoded_rk_mark_retval(struct rk_mark_retval* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_int32_t(&var->rmr_retval);

	len += sizeof(var->rmr_marks.rmr_marks_len);
	for (i = 0; i < var->rmr_marks.rmr_marks_len; i++)
		len += get_size_encoded_rk_marks(&var->rmr_marks.rmr_marks_val[i]);

	return len;
}

size_t
get_size_encoded_rk_val(struct rk_val* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_string(&var->rv_var);

	len += get_size_encoded_string(&var->rv_val);

	return len;
}

size_t
get_size_encoded_rk_uarea(struct rk_uarea* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_int32_t(&var->ru_retval);

	len += sizeof(var->ru_val.ru_val_len);
	for (i = 0; i < var->ru_val.ru_val_len; i++)
		len += get_size_encoded_rk_val(&var->ru_val.ru_val_val[i]);

	return len;
}

size_t
get_size_encoded_rk_server(struct rk_server* var)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += get_size_encoded_int32_t(&var->rs_retval);

	len += get_size_encoded_int32_t(&var->rs_proto);

	len += get_size_encoded_string(&var->rs_servtype);

	len += get_size_encoded_string(&var->rs_version);

	return len;
}



/* Implementation of get_size_decoded_XXX functions */

size_t
get_size_decoded_string(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	*dyn_len = strlen(*enc_buf) + 1;
	*stat_len = sizeof(char *);
	*enc_buf += *dyn_len;
	*dyn_len = ROUNDUP(*dyn_len, sizeof(void *));
	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_int8_t(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	*dyn_len = 0;
	*stat_len = sizeof(int8_t);
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_u_int8_t(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	*dyn_len = 0;
	*stat_len = sizeof(u_int8_t);
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_int16_t(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	*dyn_len = 0;
	*stat_len = sizeof(int16_t);
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_u_int16_t(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	*dyn_len = 0;
	*stat_len = sizeof(u_int16_t);
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_int32_t(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	*dyn_len = 0;
	*stat_len = sizeof(int32_t);
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_u_int32_t(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	*dyn_len = 0;
	*stat_len = sizeof(u_int32_t);
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_int64_t(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	*dyn_len = 0;
	*stat_len = sizeof(int64_t);
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_u_int64_t(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	*dyn_len = 0;
	*stat_len = sizeof(u_int64_t);
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_float(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	*dyn_len = 0;
	*stat_len = sizeof(float);
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_double(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	*dyn_len = 0;
	*stat_len = sizeof(double);
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_time(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_time);

	get_size_decoded_u_int8_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int8_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int8_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int8_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int8_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int16_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int8_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int16_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int8_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_misc_info(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_misc_info);

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_rk_time(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_aux_item(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_aux_item);

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_rk_time(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_string(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_aux_item_input(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_aux_item_input);

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_string(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_text_stat(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_text_stat);

	get_size_decoded_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_rk_time(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* measure a variable sized array */
	decode_u_int32_t(&n_elm, NULL, enc_buf, &d_len, &s_len);
	for (i = 0; i < n_elm; i++)
		*dyn_len += get_size_decoded_rk_misc_info(enc_buf, &d_len, &s_len);

	/* measure a variable sized array */
	decode_u_int32_t(&n_elm, NULL, enc_buf, &d_len, &s_len);
	for (i = 0; i < n_elm; i++)
		*dyn_len += get_size_decoded_rk_aux_item(enc_buf, &d_len, &s_len);

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_membership(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_membership);

	get_size_decoded_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_rk_time(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* measure a variable sized array */
	decode_u_int32_t(&n_elm, NULL, enc_buf, &d_len, &s_len);
	for (i = 0; i < n_elm; i++)
		*dyn_len += get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_rk_time(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_conference(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_conference);

	get_size_decoded_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_string(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_rk_time(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_rk_time(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* measure a variable sized array */
	decode_u_int32_t(&n_elm, NULL, enc_buf, &d_len, &s_len);
	for (i = 0; i < n_elm; i++)
		*dyn_len += get_size_decoded_rk_aux_item(enc_buf, &d_len, &s_len);

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_uconference(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_uconference);

	get_size_decoded_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_string(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_person(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_person);

	get_size_decoded_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_string(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_rk_time(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_confinfo(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_confinfo);

	get_size_decoded_string(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_confinfo_retval(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_confinfo_retval);

	/* measure a variable sized array */
	decode_u_int32_t(&n_elm, NULL, enc_buf, &d_len, &s_len);
	for (i = 0; i < n_elm; i++)
		*dyn_len += get_size_decoded_rk_confinfo(enc_buf, &d_len, &s_len);

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_dynamic_session_info(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_dynamic_session_info);

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_string(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_dynamic_session_info_retval(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_dynamic_session_info_retval);

	/* measure a variable sized array */
	decode_u_int32_t(&n_elm, NULL, enc_buf, &d_len, &s_len);
	for (i = 0; i < n_elm; i++)
		*dyn_len += get_size_decoded_rk_dynamic_session_info(enc_buf, &d_len, &s_len);

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_unreadconfval(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_unreadconfval);

	get_size_decoded_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* measure a variable sized array */
	decode_u_int32_t(&n_elm, NULL, enc_buf, &d_len, &s_len);
	for (i = 0; i < n_elm; i++)
		*dyn_len += get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_memberconflist(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_memberconflist);

	get_size_decoded_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* measure a variable sized array */
	decode_u_int32_t(&n_elm, NULL, enc_buf, &d_len, &s_len);
	for (i = 0; i < n_elm; i++)
		*dyn_len += get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_text_retval(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_text_retval);

	get_size_decoded_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_text_info(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_text_info);

	get_size_decoded_string(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* measure a variable sized array */
	decode_u_int32_t(&n_elm, NULL, enc_buf, &d_len, &s_len);
	for (i = 0; i < n_elm; i++)
		*dyn_len += get_size_decoded_rk_misc_info(enc_buf, &d_len, &s_len);

	/* measure a variable sized array */
	decode_u_int32_t(&n_elm, NULL, enc_buf, &d_len, &s_len);
	for (i = 0; i < n_elm; i++)
		*dyn_len += get_size_decoded_rk_aux_item_input(enc_buf, &d_len, &s_len);

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_modifyconfinfo(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_modifyconfinfo);

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* measure a variable sized array */
	decode_u_int32_t(&n_elm, NULL, enc_buf, &d_len, &s_len);
	for (i = 0; i < n_elm; i++)
		*dyn_len += get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);

	/* measure a variable sized array */
	decode_u_int32_t(&n_elm, NULL, enc_buf, &d_len, &s_len);
	for (i = 0; i < n_elm; i++)
		*dyn_len += get_size_decoded_rk_aux_item_input(enc_buf, &d_len, &s_len);

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_async(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_async);

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_string(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_string(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_marks(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_marks);

	get_size_decoded_u_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_u_int8_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_mark_retval(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_mark_retval);

	get_size_decoded_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* measure a variable sized array */
	decode_u_int32_t(&n_elm, NULL, enc_buf, &d_len, &s_len);
	for (i = 0; i < n_elm; i++)
		*dyn_len += get_size_decoded_rk_marks(enc_buf, &d_len, &s_len);

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_val(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_val);

	get_size_decoded_string(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_string(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_uarea(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_uarea);

	get_size_decoded_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* measure a variable sized array */
	decode_u_int32_t(&n_elm, NULL, enc_buf, &d_len, &s_len);
	for (i = 0; i < n_elm; i++)
		*dyn_len += get_size_decoded_rk_val(enc_buf, &d_len, &s_len);

	return *dyn_len + *stat_len;
}

size_t
get_size_decoded_rk_server(char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;
	u_int32_t	n_elm = 0;

	n_elm = n_elm; i = i; /*silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_server);

	get_size_decoded_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_int32_t(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_string(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	get_size_decoded_string(enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}



/* Implementation of encode_XXX functions */

size_t
encode_string(char ** var, char ** enc_buf)
{
	size_t	len;

	len = strlen(*var) + 1;
	memcpy(*enc_buf, *var, len);
	*enc_buf += len;
	return len;
}

size_t
encode_int8_t(int8_t* var, char ** enc_buf)
{
	memcpy(*enc_buf, var, sizeof(*var));
	*enc_buf += sizeof(*var);
	return sizeof(*var);
}

size_t
encode_u_int8_t(u_int8_t* var, char ** enc_buf)
{
	memcpy(*enc_buf, var, sizeof(*var));
	*enc_buf += sizeof(*var);
	return sizeof(*var);
}

size_t
encode_int16_t(int16_t* var, char ** enc_buf)
{
	memcpy(*enc_buf, var, sizeof(*var));
	*enc_buf += sizeof(*var);
	return sizeof(*var);
}

size_t
encode_u_int16_t(u_int16_t* var, char ** enc_buf)
{
	memcpy(*enc_buf, var, sizeof(*var));
	*enc_buf += sizeof(*var);
	return sizeof(*var);
}

size_t
encode_int32_t(int32_t* var, char ** enc_buf)
{
	memcpy(*enc_buf, var, sizeof(*var));
	*enc_buf += sizeof(*var);
	return sizeof(*var);
}

size_t
encode_u_int32_t(u_int32_t* var, char ** enc_buf)
{
	memcpy(*enc_buf, var, sizeof(*var));
	*enc_buf += sizeof(*var);
	return sizeof(*var);
}

size_t
encode_int64_t(int64_t* var, char ** enc_buf)
{
	memcpy(*enc_buf, var, sizeof(*var));
	*enc_buf += sizeof(*var);
	return sizeof(*var);
}

size_t
encode_u_int64_t(u_int64_t* var, char ** enc_buf)
{
	memcpy(*enc_buf, var, sizeof(*var));
	*enc_buf += sizeof(*var);
	return sizeof(*var);
}

size_t
encode_float(float* var, char ** enc_buf)
{
	memcpy(*enc_buf, var, sizeof(*var));
	*enc_buf += sizeof(*var);
	return sizeof(*var);
}

size_t
encode_double(double* var, char ** enc_buf)
{
	memcpy(*enc_buf, var, sizeof(*var));
	*enc_buf += sizeof(*var);
	return sizeof(*var);
}

size_t
encode_rk_time(struct rk_time* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_u_int8_t(&var->rt_seconds, enc_buf);
	len += encode_u_int8_t(&var->rt_minutes, enc_buf);
	len += encode_u_int8_t(&var->rt_hours, enc_buf);
	len += encode_u_int8_t(&var->rt_day, enc_buf);
	len += encode_u_int8_t(&var->rt_month, enc_buf);
	len += encode_u_int16_t(&var->rt_year, enc_buf);
	len += encode_u_int8_t(&var->rt_day_of_week, enc_buf);
	len += encode_u_int16_t(&var->rt_day_of_year, enc_buf);
	len += encode_u_int8_t(&var->rt_is_dst, enc_buf);
	return len;
}

size_t
encode_rk_misc_info(struct rk_misc_info* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_u_int32_t(&var->rmi_type, enc_buf);
	len += encode_u_int32_t(&var->rmi_numeric, enc_buf);
	len += encode_rk_time(&var->rmi_time, enc_buf);
	return len;
}

size_t
encode_rk_aux_item(struct rk_aux_item* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_u_int32_t(&var->rai_aux_no, enc_buf);
	len += encode_u_int32_t(&var->rai_tag, enc_buf);
	len += encode_u_int32_t(&var->rai_creator, enc_buf);
	len += encode_rk_time(&var->rai_created_at, enc_buf);
	len += encode_u_int32_t(&var->rai_flags, enc_buf);
	len += encode_u_int32_t(&var->inherit_limit, enc_buf);
	len += encode_string(&var->rai_data, enc_buf);
	return len;
}

size_t
encode_rk_aux_item_input(struct rk_aux_item_input* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_u_int32_t(&var->raii_tag, enc_buf);
	len += encode_u_int32_t(&var->raii_flags, enc_buf);
	len += encode_u_int32_t(&var->inherit_limit, enc_buf);
	len += encode_string(&var->raii_data, enc_buf);
	return len;
}

size_t
encode_rk_text_stat(struct rk_text_stat* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_int32_t(&var->rt_retval, enc_buf);
	len += encode_rk_time(&var->rt_time, enc_buf);
	len += encode_u_int32_t(&var->rt_author, enc_buf);
	len += encode_u_int32_t(&var->rt_no_of_lines, enc_buf);
	len += encode_u_int32_t(&var->rt_no_of_chars, enc_buf);
	len += encode_u_int32_t(&var->rt_no_of_marks, enc_buf);
	len += encode_u_int32_t(&var->rt_misc_info.rt_misc_info_len, enc_buf);
	for (i = 0; i < var->rt_misc_info.rt_misc_info_len; i++)
		len += encode_rk_misc_info(&var->rt_misc_info.rt_misc_info_val[i], enc_buf);

	len += encode_u_int32_t(&var->rt_aux_item.rt_aux_item_len, enc_buf);
	for (i = 0; i < var->rt_aux_item.rt_aux_item_len; i++)
		len += encode_rk_aux_item(&var->rt_aux_item.rt_aux_item_val[i], enc_buf);

	return len;
}

size_t
encode_rk_membership(struct rk_membership* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_int32_t(&var->rm_retval, enc_buf);
	len += encode_u_int32_t(&var->rm_position, enc_buf);
	len += encode_rk_time(&var->rm_last_time_read, enc_buf);
	len += encode_u_int32_t(&var->rm_conference, enc_buf);
	len += encode_u_int32_t(&var->rm_priority, enc_buf);
	len += encode_u_int32_t(&var->rm_last_text_read, enc_buf);
	len += encode_u_int32_t(&var->rm_read_texts.rm_read_texts_len, enc_buf);
	for (i = 0; i < var->rm_read_texts.rm_read_texts_len; i++)
		len += encode_u_int32_t(&var->rm_read_texts.rm_read_texts_val[i], enc_buf);

	len += encode_u_int32_t(&var->rm_added_by, enc_buf);
	len += encode_rk_time(&var->rm_added_at, enc_buf);
	len += encode_u_int32_t(&var->rm_type, enc_buf);
	return len;
}

size_t
encode_rk_conference(struct rk_conference* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_int32_t(&var->rc_retval, enc_buf);
	len += encode_string(&var->rc_name, enc_buf);
	len += encode_u_int32_t(&var->rc_type, enc_buf);
	len += encode_rk_time(&var->rc_creation_time, enc_buf);
	len += encode_rk_time(&var->rc_last_written, enc_buf);
	len += encode_u_int32_t(&var->rc_creator, enc_buf);
	len += encode_u_int32_t(&var->rc_presentation, enc_buf);
	len += encode_u_int32_t(&var->rc_supervisor, enc_buf);
	len += encode_u_int32_t(&var->rc_permitted_submitters, enc_buf);
	len += encode_u_int32_t(&var->rc_super_conf, enc_buf);
	len += encode_u_int32_t(&var->rc_msg_of_day, enc_buf);
	len += encode_u_int32_t(&var->rc_nice, enc_buf);
	len += encode_u_int32_t(&var->rc_keep_commented, enc_buf);
	len += encode_u_int32_t(&var->rc_no_of_members, enc_buf);
	len += encode_u_int32_t(&var->rc_first_local_no, enc_buf);
	len += encode_u_int32_t(&var->rc_no_of_texts, enc_buf);
	len += encode_u_int32_t(&var->rc_expire, enc_buf);
	len += encode_u_int32_t(&var->rc_aux_item.rc_aux_item_len, enc_buf);
	for (i = 0; i < var->rc_aux_item.rc_aux_item_len; i++)
		len += encode_rk_aux_item(&var->rc_aux_item.rc_aux_item_val[i], enc_buf);

	return len;
}

size_t
encode_rk_uconference(struct rk_uconference* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_int32_t(&var->ru_retval, enc_buf);
	len += encode_string(&var->ru_name, enc_buf);
	len += encode_u_int32_t(&var->ru_type, enc_buf);
	len += encode_u_int32_t(&var->ru_highest_local_no, enc_buf);
	len += encode_u_int32_t(&var->ru_nice, enc_buf);
	return len;
}

size_t
encode_rk_person(struct rk_person* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_int32_t(&var->rp_retval, enc_buf);
	len += encode_string(&var->rp_username, enc_buf);
	len += encode_u_int32_t(&var->rp_privileges, enc_buf);
	len += encode_u_int32_t(&var->rp_flags, enc_buf);
	len += encode_rk_time(&var->rp_last_login, enc_buf);
	len += encode_u_int32_t(&var->rp_user_area, enc_buf);
	len += encode_u_int32_t(&var->rp_total_time_present, enc_buf);
	len += encode_u_int32_t(&var->rp_sessions, enc_buf);
	len += encode_u_int32_t(&var->rp_created_lines, enc_buf);
	len += encode_u_int32_t(&var->rp_created_bytes, enc_buf);
	len += encode_u_int32_t(&var->rp_read_texts, enc_buf);
	len += encode_u_int32_t(&var->rp_no_of_text_fetches, enc_buf);
	len += encode_u_int32_t(&var->rp_created_persons, enc_buf);
	len += encode_u_int32_t(&var->rp_created_confs, enc_buf);
	len += encode_u_int32_t(&var->rp_first_created_local_no, enc_buf);
	len += encode_u_int32_t(&var->rp_no_of_created_texts, enc_buf);
	len += encode_u_int32_t(&var->rp_no_of_marks, enc_buf);
	len += encode_u_int32_t(&var->rp_no_of_confs, enc_buf);
	return len;
}

size_t
encode_rk_confinfo(struct rk_confinfo* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_string(&var->rc_name, enc_buf);
	len += encode_u_int32_t(&var->rc_type, enc_buf);
	len += encode_u_int32_t(&var->rc_conf_no, enc_buf);
	return len;
}

size_t
encode_rk_confinfo_retval(struct rk_confinfo_retval* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_u_int32_t(&var->rcr_ci.rcr_ci_len, enc_buf);
	for (i = 0; i < var->rcr_ci.rcr_ci_len; i++)
		len += encode_rk_confinfo(&var->rcr_ci.rcr_ci_val[i], enc_buf);

	return len;
}

size_t
encode_rk_dynamic_session_info(struct rk_dynamic_session_info* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_u_int32_t(&var->rds_session, enc_buf);
	len += encode_u_int32_t(&var->rds_person, enc_buf);
	len += encode_u_int32_t(&var->rds_conf, enc_buf);
	len += encode_u_int32_t(&var->rds_idletime, enc_buf);
	len += encode_u_int32_t(&var->rds_flags, enc_buf);
	len += encode_string(&var->rds_doing, enc_buf);
	return len;
}

size_t
encode_rk_dynamic_session_info_retval(struct rk_dynamic_session_info_retval* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_u_int32_t(&var->rdv_rds.rdv_rds_len, enc_buf);
	for (i = 0; i < var->rdv_rds.rdv_rds_len; i++)
		len += encode_rk_dynamic_session_info(&var->rdv_rds.rdv_rds_val[i], enc_buf);

	return len;
}

size_t
encode_rk_unreadconfval(struct rk_unreadconfval* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_int32_t(&var->ru_retval, enc_buf);
	len += encode_u_int32_t(&var->ru_confs.ru_confs_len, enc_buf);
	for (i = 0; i < var->ru_confs.ru_confs_len; i++)
		len += encode_u_int32_t(&var->ru_confs.ru_confs_val[i], enc_buf);

	return len;
}

size_t
encode_rk_memberconflist(struct rk_memberconflist* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_int32_t(&var->rm_retval, enc_buf);
	len += encode_u_int32_t(&var->rm_confs.rm_confs_len, enc_buf);
	for (i = 0; i < var->rm_confs.rm_confs_len; i++)
		len += encode_u_int32_t(&var->rm_confs.rm_confs_val[i], enc_buf);

	return len;
}

size_t
encode_rk_text_retval(struct rk_text_retval* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_int32_t(&var->rtr_status, enc_buf);
	len += encode_u_int32_t(&var->rtr_textnr, enc_buf);
	return len;
}

size_t
encode_rk_text_info(struct rk_text_info* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_string(&var->rti_text, enc_buf);
	len += encode_u_int32_t(&var->rti_misc.rti_misc_len, enc_buf);
	for (i = 0; i < var->rti_misc.rti_misc_len; i++)
		len += encode_rk_misc_info(&var->rti_misc.rti_misc_val[i], enc_buf);

	len += encode_u_int32_t(&var->rti_input.rti_input_len, enc_buf);
	for (i = 0; i < var->rti_input.rti_input_len; i++)
		len += encode_rk_aux_item_input(&var->rti_input.rti_input_val[i], enc_buf);

	return len;
}

size_t
encode_rk_modifyconfinfo(struct rk_modifyconfinfo* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_u_int32_t(&var->rkm_conf, enc_buf);
	len += encode_u_int32_t(&var->rkm_delete.rkm_delete_len, enc_buf);
	for (i = 0; i < var->rkm_delete.rkm_delete_len; i++)
		len += encode_u_int32_t(&var->rkm_delete.rkm_delete_val[i], enc_buf);

	len += encode_u_int32_t(&var->rkm_add.rkm_add_len, enc_buf);
	for (i = 0; i < var->rkm_add.rkm_add_len; i++)
		len += encode_rk_aux_item_input(&var->rkm_add.rkm_add_val[i], enc_buf);

	return len;
}

size_t
encode_rk_async(struct rk_async* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_u_int32_t(&var->ra_type, enc_buf);
	len += encode_u_int32_t(&var->ra_conf, enc_buf);
	len += encode_u_int32_t(&var->ra_pers, enc_buf);
	len += encode_u_int32_t(&var->ra_text, enc_buf);
	len += encode_string(&var->ra_message, enc_buf);
	len += encode_string(&var->ra_message2, enc_buf);
	return len;
}

size_t
encode_rk_marks(struct rk_marks* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_u_int32_t(&var->rm_text, enc_buf);
	len += encode_u_int8_t(&var->rm_type, enc_buf);
	return len;
}

size_t
encode_rk_mark_retval(struct rk_mark_retval* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_int32_t(&var->rmr_retval, enc_buf);
	len += encode_u_int32_t(&var->rmr_marks.rmr_marks_len, enc_buf);
	for (i = 0; i < var->rmr_marks.rmr_marks_len; i++)
		len += encode_rk_marks(&var->rmr_marks.rmr_marks_val[i], enc_buf);

	return len;
}

size_t
encode_rk_val(struct rk_val* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_string(&var->rv_var, enc_buf);
	len += encode_string(&var->rv_val, enc_buf);
	return len;
}

size_t
encode_rk_uarea(struct rk_uarea* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_int32_t(&var->ru_retval, enc_buf);
	len += encode_u_int32_t(&var->ru_val.ru_val_len, enc_buf);
	for (i = 0; i < var->ru_val.ru_val_len; i++)
		len += encode_rk_val(&var->ru_val.ru_val_val[i], enc_buf);

	return len;
}

size_t
encode_rk_server(struct rk_server* var, char ** enc_buf)
{
	size_t	len = 0;
	int		i = 0;

	i = i; /* silent gcc */
	len += encode_int32_t(&var->rs_retval, enc_buf);
	len += encode_int32_t(&var->rs_proto, enc_buf);
	len += encode_string(&var->rs_servtype, enc_buf);
	len += encode_string(&var->rs_version, enc_buf);
	return len;
}



/* Implementation of decode_XXX functions */

size_t	decode_string(char * * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	*dyn_len = strlen(*enc_buf) + 1;
	*stat_len = sizeof(char *);
	*var = *dyn_buf;
	memcpy(*var, *enc_buf, *dyn_len);
	*enc_buf += *dyn_len;
	*dyn_len = ROUNDUP(*dyn_len, sizeof(void *));
	*dyn_buf += *dyn_len;
	return *dyn_len + *stat_len;
}

size_t	decode_int8_t(int8_t * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	memcpy(var, *enc_buf, sizeof(*var));
	*stat_len = sizeof(*var);
	*dyn_len = 0;
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t	decode_u_int8_t(u_int8_t * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	memcpy(var, *enc_buf, sizeof(*var));
	*stat_len = sizeof(*var);
	*dyn_len = 0;
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t	decode_int16_t(int16_t * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	memcpy(var, *enc_buf, sizeof(*var));
	*stat_len = sizeof(*var);
	*dyn_len = 0;
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t	decode_u_int16_t(u_int16_t * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	memcpy(var, *enc_buf, sizeof(*var));
	*stat_len = sizeof(*var);
	*dyn_len = 0;
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t	decode_int32_t(int32_t * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	memcpy(var, *enc_buf, sizeof(*var));
	*stat_len = sizeof(*var);
	*dyn_len = 0;
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t	decode_u_int32_t(u_int32_t * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	memcpy(var, *enc_buf, sizeof(*var));
	*stat_len = sizeof(*var);
	*dyn_len = 0;
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t	decode_int64_t(int64_t * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	memcpy(var, *enc_buf, sizeof(*var));
	*stat_len = sizeof(*var);
	*dyn_len = 0;
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t	decode_u_int64_t(u_int64_t * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	memcpy(var, *enc_buf, sizeof(*var));
	*stat_len = sizeof(*var);
	*dyn_len = 0;
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t	decode_float(float * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	memcpy(var, *enc_buf, sizeof(*var));
	*stat_len = sizeof(*var);
	*dyn_len = 0;
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t	decode_double(double * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	memcpy(var, *enc_buf, sizeof(*var));
	*stat_len = sizeof(*var);
	*dyn_len = 0;
	*enc_buf += *stat_len;
	return *dyn_len + *stat_len;
}

size_t	decode_rk_time(struct rk_time * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_time);

	decode_u_int8_t(&var->rt_seconds, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int8_t(&var->rt_minutes, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int8_t(&var->rt_hours, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int8_t(&var->rt_day, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int8_t(&var->rt_month, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int16_t(&var->rt_year, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int8_t(&var->rt_day_of_week, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int16_t(&var->rt_day_of_year, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int8_t(&var->rt_is_dst, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t	decode_rk_misc_info(struct rk_misc_info * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_misc_info);

	decode_u_int32_t(&var->rmi_type, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rmi_numeric, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_rk_time(&var->rmi_time, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t	decode_rk_aux_item(struct rk_aux_item * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_aux_item);

	decode_u_int32_t(&var->rai_aux_no, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rai_tag, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rai_creator, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_rk_time(&var->rai_created_at, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rai_flags, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->inherit_limit, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_string(&var->rai_data, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t	decode_rk_aux_item_input(struct rk_aux_item_input * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_aux_item_input);

	decode_u_int32_t(&var->raii_tag, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->raii_flags, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->inherit_limit, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_string(&var->raii_data, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t	decode_rk_text_stat(struct rk_text_stat * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_text_stat);

	decode_int32_t(&var->rt_retval, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_rk_time(&var->rt_time, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rt_author, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rt_no_of_lines, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rt_no_of_chars, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rt_no_of_marks, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* Decode an array of variably size */
	decode_u_int32_t(&var->rt_misc_info.rt_misc_info_len, NULL, enc_buf,
			&d_len, &s_len);
	var->rt_misc_info.rt_misc_info_val = (void *)*dyn_buf;
	*dyn_buf += var->rt_misc_info.rt_misc_info_len * sizeof(struct rk_misc_info);
	for (i = 0; i < var->rt_misc_info.rt_misc_info_len; i++) {
		decode_rk_misc_info(&var->rt_misc_info.rt_misc_info_val[i], dyn_buf, enc_buf,
			&d_len, &s_len);
		*dyn_len += d_len;
	}

	/* Decode an array of variably size */
	decode_u_int32_t(&var->rt_aux_item.rt_aux_item_len, NULL, enc_buf,
			&d_len, &s_len);
	var->rt_aux_item.rt_aux_item_val = (void *)*dyn_buf;
	*dyn_buf += var->rt_aux_item.rt_aux_item_len * sizeof(struct rk_aux_item);
	for (i = 0; i < var->rt_aux_item.rt_aux_item_len; i++) {
		decode_rk_aux_item(&var->rt_aux_item.rt_aux_item_val[i], dyn_buf, enc_buf,
			&d_len, &s_len);
		*dyn_len += d_len;
	}

	return *dyn_len + *stat_len;
}

size_t	decode_rk_membership(struct rk_membership * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_membership);

	decode_int32_t(&var->rm_retval, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rm_position, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_rk_time(&var->rm_last_time_read, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rm_conference, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rm_priority, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rm_last_text_read, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* Decode an array of variably size */
	decode_u_int32_t(&var->rm_read_texts.rm_read_texts_len, NULL, enc_buf,
			&d_len, &s_len);
	var->rm_read_texts.rm_read_texts_val = (void *)*dyn_buf;
	*dyn_buf += var->rm_read_texts.rm_read_texts_len * sizeof(u_int32_t);
	for (i = 0; i < var->rm_read_texts.rm_read_texts_len; i++) {
		decode_u_int32_t(&var->rm_read_texts.rm_read_texts_val[i], dyn_buf, enc_buf,
			&d_len, &s_len);
		*dyn_len += d_len;
	}

	decode_u_int32_t(&var->rm_added_by, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_rk_time(&var->rm_added_at, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rm_type, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t	decode_rk_conference(struct rk_conference * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_conference);

	decode_int32_t(&var->rc_retval, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_string(&var->rc_name, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rc_type, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_rk_time(&var->rc_creation_time, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_rk_time(&var->rc_last_written, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rc_creator, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rc_presentation, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rc_supervisor, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rc_permitted_submitters, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rc_super_conf, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rc_msg_of_day, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rc_nice, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rc_keep_commented, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rc_no_of_members, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rc_first_local_no, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rc_no_of_texts, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rc_expire, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* Decode an array of variably size */
	decode_u_int32_t(&var->rc_aux_item.rc_aux_item_len, NULL, enc_buf,
			&d_len, &s_len);
	var->rc_aux_item.rc_aux_item_val = (void *)*dyn_buf;
	*dyn_buf += var->rc_aux_item.rc_aux_item_len * sizeof(struct rk_aux_item);
	for (i = 0; i < var->rc_aux_item.rc_aux_item_len; i++) {
		decode_rk_aux_item(&var->rc_aux_item.rc_aux_item_val[i], dyn_buf, enc_buf,
			&d_len, &s_len);
		*dyn_len += d_len;
	}

	return *dyn_len + *stat_len;
}

size_t	decode_rk_uconference(struct rk_uconference * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_uconference);

	decode_int32_t(&var->ru_retval, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_string(&var->ru_name, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->ru_type, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->ru_highest_local_no, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->ru_nice, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t	decode_rk_person(struct rk_person * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_person);

	decode_int32_t(&var->rp_retval, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_string(&var->rp_username, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rp_privileges, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rp_flags, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_rk_time(&var->rp_last_login, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rp_user_area, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rp_total_time_present, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rp_sessions, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rp_created_lines, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rp_created_bytes, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rp_read_texts, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rp_no_of_text_fetches, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rp_created_persons, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rp_created_confs, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rp_first_created_local_no, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rp_no_of_created_texts, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rp_no_of_marks, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rp_no_of_confs, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t	decode_rk_confinfo(struct rk_confinfo * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_confinfo);

	decode_string(&var->rc_name, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rc_type, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rc_conf_no, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t	decode_rk_confinfo_retval(struct rk_confinfo_retval * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_confinfo_retval);

	/* Decode an array of variably size */
	decode_u_int32_t(&var->rcr_ci.rcr_ci_len, NULL, enc_buf,
			&d_len, &s_len);
	var->rcr_ci.rcr_ci_val = (void *)*dyn_buf;
	*dyn_buf += var->rcr_ci.rcr_ci_len * sizeof(struct rk_confinfo);
	for (i = 0; i < var->rcr_ci.rcr_ci_len; i++) {
		decode_rk_confinfo(&var->rcr_ci.rcr_ci_val[i], dyn_buf, enc_buf,
			&d_len, &s_len);
		*dyn_len += d_len;
	}

	return *dyn_len + *stat_len;
}

size_t	decode_rk_dynamic_session_info(struct rk_dynamic_session_info * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_dynamic_session_info);

	decode_u_int32_t(&var->rds_session, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rds_person, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rds_conf, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rds_idletime, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rds_flags, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_string(&var->rds_doing, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t	decode_rk_dynamic_session_info_retval(struct rk_dynamic_session_info_retval * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_dynamic_session_info_retval);

	/* Decode an array of variably size */
	decode_u_int32_t(&var->rdv_rds.rdv_rds_len, NULL, enc_buf,
			&d_len, &s_len);
	var->rdv_rds.rdv_rds_val = (void *)*dyn_buf;
	*dyn_buf += var->rdv_rds.rdv_rds_len * sizeof(struct rk_dynamic_session_info);
	for (i = 0; i < var->rdv_rds.rdv_rds_len; i++) {
		decode_rk_dynamic_session_info(&var->rdv_rds.rdv_rds_val[i], dyn_buf, enc_buf,
			&d_len, &s_len);
		*dyn_len += d_len;
	}

	return *dyn_len + *stat_len;
}

size_t	decode_rk_unreadconfval(struct rk_unreadconfval * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_unreadconfval);

	decode_int32_t(&var->ru_retval, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* Decode an array of variably size */
	decode_u_int32_t(&var->ru_confs.ru_confs_len, NULL, enc_buf,
			&d_len, &s_len);
	var->ru_confs.ru_confs_val = (void *)*dyn_buf;
	*dyn_buf += var->ru_confs.ru_confs_len * sizeof(u_int32_t);
	for (i = 0; i < var->ru_confs.ru_confs_len; i++) {
		decode_u_int32_t(&var->ru_confs.ru_confs_val[i], dyn_buf, enc_buf,
			&d_len, &s_len);
		*dyn_len += d_len;
	}

	return *dyn_len + *stat_len;
}

size_t	decode_rk_memberconflist(struct rk_memberconflist * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_memberconflist);

	decode_int32_t(&var->rm_retval, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* Decode an array of variably size */
	decode_u_int32_t(&var->rm_confs.rm_confs_len, NULL, enc_buf,
			&d_len, &s_len);
	var->rm_confs.rm_confs_val = (void *)*dyn_buf;
	*dyn_buf += var->rm_confs.rm_confs_len * sizeof(u_int32_t);
	for (i = 0; i < var->rm_confs.rm_confs_len; i++) {
		decode_u_int32_t(&var->rm_confs.rm_confs_val[i], dyn_buf, enc_buf,
			&d_len, &s_len);
		*dyn_len += d_len;
	}

	return *dyn_len + *stat_len;
}

size_t	decode_rk_text_retval(struct rk_text_retval * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_text_retval);

	decode_int32_t(&var->rtr_status, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->rtr_textnr, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t	decode_rk_text_info(struct rk_text_info * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_text_info);

	decode_string(&var->rti_text, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* Decode an array of variably size */
	decode_u_int32_t(&var->rti_misc.rti_misc_len, NULL, enc_buf,
			&d_len, &s_len);
	var->rti_misc.rti_misc_val = (void *)*dyn_buf;
	*dyn_buf += var->rti_misc.rti_misc_len * sizeof(struct rk_misc_info);
	for (i = 0; i < var->rti_misc.rti_misc_len; i++) {
		decode_rk_misc_info(&var->rti_misc.rti_misc_val[i], dyn_buf, enc_buf,
			&d_len, &s_len);
		*dyn_len += d_len;
	}

	/* Decode an array of variably size */
	decode_u_int32_t(&var->rti_input.rti_input_len, NULL, enc_buf,
			&d_len, &s_len);
	var->rti_input.rti_input_val = (void *)*dyn_buf;
	*dyn_buf += var->rti_input.rti_input_len * sizeof(struct rk_aux_item_input);
	for (i = 0; i < var->rti_input.rti_input_len; i++) {
		decode_rk_aux_item_input(&var->rti_input.rti_input_val[i], dyn_buf, enc_buf,
			&d_len, &s_len);
		*dyn_len += d_len;
	}

	return *dyn_len + *stat_len;
}

size_t	decode_rk_modifyconfinfo(struct rk_modifyconfinfo * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_modifyconfinfo);

	decode_u_int32_t(&var->rkm_conf, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* Decode an array of variably size */
	decode_u_int32_t(&var->rkm_delete.rkm_delete_len, NULL, enc_buf,
			&d_len, &s_len);
	var->rkm_delete.rkm_delete_val = (void *)*dyn_buf;
	*dyn_buf += var->rkm_delete.rkm_delete_len * sizeof(u_int32_t);
	for (i = 0; i < var->rkm_delete.rkm_delete_len; i++) {
		decode_u_int32_t(&var->rkm_delete.rkm_delete_val[i], dyn_buf, enc_buf,
			&d_len, &s_len);
		*dyn_len += d_len;
	}

	/* Decode an array of variably size */
	decode_u_int32_t(&var->rkm_add.rkm_add_len, NULL, enc_buf,
			&d_len, &s_len);
	var->rkm_add.rkm_add_val = (void *)*dyn_buf;
	*dyn_buf += var->rkm_add.rkm_add_len * sizeof(struct rk_aux_item_input);
	for (i = 0; i < var->rkm_add.rkm_add_len; i++) {
		decode_rk_aux_item_input(&var->rkm_add.rkm_add_val[i], dyn_buf, enc_buf,
			&d_len, &s_len);
		*dyn_len += d_len;
	}

	return *dyn_len + *stat_len;
}

size_t	decode_rk_async(struct rk_async * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_async);

	decode_u_int32_t(&var->ra_type, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->ra_conf, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->ra_pers, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int32_t(&var->ra_text, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_string(&var->ra_message, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_string(&var->ra_message2, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t	decode_rk_marks(struct rk_marks * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_marks);

	decode_u_int32_t(&var->rm_text, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_u_int8_t(&var->rm_type, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t	decode_rk_mark_retval(struct rk_mark_retval * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_mark_retval);

	decode_int32_t(&var->rmr_retval, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* Decode an array of variably size */
	decode_u_int32_t(&var->rmr_marks.rmr_marks_len, NULL, enc_buf,
			&d_len, &s_len);
	var->rmr_marks.rmr_marks_val = (void *)*dyn_buf;
	*dyn_buf += var->rmr_marks.rmr_marks_len * sizeof(struct rk_marks);
	for (i = 0; i < var->rmr_marks.rmr_marks_len; i++) {
		decode_rk_marks(&var->rmr_marks.rmr_marks_val[i], dyn_buf, enc_buf,
			&d_len, &s_len);
		*dyn_len += d_len;
	}

	return *dyn_len + *stat_len;
}

size_t	decode_rk_val(struct rk_val * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_val);

	decode_string(&var->rv_var, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_string(&var->rv_val, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}

size_t	decode_rk_uarea(struct rk_uarea * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_uarea);

	decode_int32_t(&var->ru_retval, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	/* Decode an array of variably size */
	decode_u_int32_t(&var->ru_val.ru_val_len, NULL, enc_buf,
			&d_len, &s_len);
	var->ru_val.ru_val_val = (void *)*dyn_buf;
	*dyn_buf += var->ru_val.ru_val_len * sizeof(struct rk_val);
	for (i = 0; i < var->ru_val.ru_val_len; i++) {
		decode_rk_val(&var->ru_val.ru_val_val[i], dyn_buf, enc_buf,
			&d_len, &s_len);
		*dyn_len += d_len;
	}

	return *dyn_len + *stat_len;
}

size_t	decode_rk_server(struct rk_server * var, char **dyn_buf, char **enc_buf,
			size_t *dyn_len, size_t *stat_len)
{
	size_t		d_len, s_len;
	int			i = 0;

	i = i; /* silent gcc */
	*dyn_len = 0;
	*stat_len = sizeof(struct rk_server);

	decode_int32_t(&var->rs_retval, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_int32_t(&var->rs_proto, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_string(&var->rs_servtype, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	decode_string(&var->rs_version, dyn_buf, enc_buf, &d_len, &s_len);
	*dyn_len += d_len;

	return *dyn_len + *stat_len;
}



/* Implementation of client functions */

struct rk_server * 
rk_connect(char * arg0, char * arg1, char * arg2, char * arg3)
{
	struct rk_server *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_string(&arg0);
	msglen += get_size_encoded_string(&arg1);
	msglen += get_size_encoded_string(&arg2);
	msglen += get_size_encoded_string(&arg3);
	fnum = 0;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_string(&arg0, &enc_buf);
	encode_string(&arg1, &enc_buf);
	encode_string(&arg2, &enc_buf);
	encode_string(&arg3, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_rk_server(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(*ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val + 1);
	enc_buf = buf_start;
	decode_rk_server(ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_login(u_int32_t arg0, char * arg1)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_string(&arg1);
	fnum = 1;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_string(&arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_whatido(char * arg0)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_string(&arg0);
	fnum = 2;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_string(&arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

struct rk_unreadconfval * 
rk_unreadconf(u_int32_t arg0)
{
	struct rk_unreadconfval *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	fnum = 3;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_rk_unreadconfval(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(*ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val + 1);
	enc_buf = buf_start;
	decode_rk_unreadconfval(ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

struct rk_memberconflist * 
rk_memberconf(u_int32_t arg0)
{
	struct rk_memberconflist *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	fnum = 4;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_rk_memberconflist(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(*ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val + 1);
	enc_buf = buf_start;
	decode_rk_memberconflist(ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

struct rk_confinfo_retval * 
rk_matchconf(char * arg0, u_int8_t arg1)
{
	struct rk_confinfo_retval *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_string(&arg0);
	msglen += get_size_encoded_u_int8_t(&arg1);
	fnum = 5;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_string(&arg0, &enc_buf);
	encode_u_int8_t(&arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_rk_confinfo_retval(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(*ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val + 1);
	enc_buf = buf_start;
	decode_rk_confinfo_retval(ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

struct rk_uconference * 
rk_uconfinfo(u_int32_t arg0)
{
	struct rk_uconference *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	fnum = 6;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_rk_uconference(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(*ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val + 1);
	enc_buf = buf_start;
	decode_rk_uconference(ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

struct rk_conference * 
rk_confinfo(u_int32_t arg0)
{
	struct rk_conference *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	fnum = 7;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_rk_conference(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(*ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val + 1);
	enc_buf = buf_start;
	decode_rk_conference(ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

struct rk_person * 
rk_persinfo(u_int32_t arg0)
{
	struct rk_person *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	fnum = 8;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_rk_person(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(*ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val + 1);
	enc_buf = buf_start;
	decode_rk_person(ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

void 
rk_alive(void)
{
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	fnum = 9;
	buf_start = NULL;
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);
}

struct rk_membership * 
rk_membership(u_int32_t arg0, u_int32_t arg1)
{
	struct rk_membership *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_u_int32_t(&arg1);
	fnum = 10;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_u_int32_t(&arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_rk_membership(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(*ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val + 1);
	enc_buf = buf_start;
	decode_rk_membership(ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

struct rk_dynamic_session_info_retval * 
rk_vilka(u_int32_t arg0, u_int32_t arg1)
{
	struct rk_dynamic_session_info_retval *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_u_int32_t(&arg1);
	fnum = 11;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_u_int32_t(&arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_rk_dynamic_session_info_retval(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(*ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val + 1);
	enc_buf = buf_start;
	decode_rk_dynamic_session_info_retval(ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

char * 
rk_client_version(u_int32_t arg0)
{
	char *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	fnum = 12;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_string(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val);
	enc_buf = buf_start;
	decode_string(&ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

char * 
rk_client_name(u_int32_t arg0)
{
	char *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	fnum = 13;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_string(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val);
	enc_buf = buf_start;
	decode_string(&ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

struct rk_time * 
rk_time(void)
{
	struct rk_time *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	fnum = 14;
	buf_start = NULL;
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_rk_time(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(*ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val + 1);
	enc_buf = buf_start;
	decode_rk_time(ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

u_int32_t 
rk_next_unread(u_int32_t arg0, u_int32_t arg1)
{
	u_int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_u_int32_t(&arg1);
	fnum = 15;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_u_int32_t(&arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_u_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

u_int32_t 
rk_local_to_global(u_int32_t arg0, u_int32_t arg1)
{
	u_int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_u_int32_t(&arg1);
	fnum = 16;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_u_int32_t(&arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_u_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_mark_read(u_int32_t arg0, u_int32_t arg1)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_u_int32_t(&arg1);
	fnum = 17;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_u_int32_t(&arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_is_read(u_int32_t arg0)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	fnum = 18;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

struct rk_text_stat * 
rk_textstat(u_int32_t arg0)
{
	struct rk_text_stat *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	fnum = 19;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_rk_text_stat(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(*ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val + 1);
	enc_buf = buf_start;
	decode_rk_text_stat(ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

char * 
rk_gettext(u_int32_t arg0)
{
	char *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	fnum = 20;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_string(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val);
	enc_buf = buf_start;
	decode_string(&ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_set_last_read(u_int32_t arg0, u_int32_t arg1)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_u_int32_t(&arg1);
	fnum = 21;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_u_int32_t(&arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_change_conference(u_int32_t arg0)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	fnum = 22;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_add_member(u_int32_t arg0, u_int32_t arg1, u_int8_t arg2, u_int16_t arg3, u_int32_t arg4)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_u_int32_t(&arg1);
	msglen += get_size_encoded_u_int8_t(&arg2);
	msglen += get_size_encoded_u_int16_t(&arg3);
	msglen += get_size_encoded_u_int32_t(&arg4);
	fnum = 23;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_u_int32_t(&arg1, &enc_buf);
	encode_u_int8_t(&arg2, &enc_buf);
	encode_u_int16_t(&arg3, &enc_buf);
	encode_u_int32_t(&arg4, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_sub_member(u_int32_t arg0, u_int32_t arg1)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_u_int32_t(&arg1);
	fnum = 24;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_u_int32_t(&arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_add_rcpt(u_int32_t arg0, u_int32_t arg1, u_int32_t arg2)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_u_int32_t(&arg1);
	msglen += get_size_encoded_u_int32_t(&arg2);
	fnum = 25;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_u_int32_t(&arg1, &enc_buf);
	encode_u_int32_t(&arg2, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_sub_rcpt(u_int32_t arg0, u_int32_t arg1)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_u_int32_t(&arg1);
	fnum = 26;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_u_int32_t(&arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

struct rk_text_retval * 
rk_create_text(struct rk_text_info * arg0)
{
	struct rk_text_retval *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_rk_text_info(arg0);
	fnum = 27;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_rk_text_info(arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_rk_text_retval(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(*ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val + 1);
	enc_buf = buf_start;
	decode_rk_text_retval(ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

struct rk_async * 
rk_async(void)
{
	struct rk_async *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	fnum = 28;
	buf_start = NULL;
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_rk_async(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(*ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val + 1);
	enc_buf = buf_start;
	decode_rk_async(ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_send_msg(u_int32_t arg0, char * arg1)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_string(&arg1);
	fnum = 29;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_string(&arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

struct rk_mark_retval * 
rk_getmarks(void)
{
	struct rk_mark_retval *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	fnum = 30;
	buf_start = NULL;
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_rk_mark_retval(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(*ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val + 1);
	enc_buf = buf_start;
	decode_rk_mark_retval(ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_setmark(u_int32_t arg0, u_int8_t arg1)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_u_int8_t(&arg1);
	fnum = 31;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_u_int8_t(&arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_unmark(u_int32_t arg0)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	fnum = 32;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

struct rk_uarea * 
rk_get_uarea(char * arg0)
{
	struct rk_uarea *ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_string(&arg0);
	fnum = 33;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_string(&arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	get_size_decoded_rk_uarea(&enc_buf, &d_len, &s_len);
	assert(s_len == sizeof(*ret_val));
	if ((ret_val = malloc(d_len + s_len)) == NULL)
		err(1, "malloc");
	dyn_buf = (char *)(ret_val + 1);
	enc_buf = buf_start;
	decode_rk_uarea(ret_val, &dyn_buf, &enc_buf, &d_len, &s_len);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_set_uarea(char * arg0, struct rk_uarea * arg1)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_string(&arg0);
	msglen += get_size_encoded_rk_uarea(arg1);
	fnum = 34;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_string(&arg0, &enc_buf);
	encode_rk_uarea(arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_setpass(u_int32_t arg0, char * arg1, char * arg2)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_string(&arg1);
	msglen += get_size_encoded_string(&arg2);
	fnum = 35;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_string(&arg1, &enc_buf);
	encode_string(&arg2, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_change_name(u_int32_t arg0, char * arg1)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_string(&arg1);
	fnum = 36;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_string(&arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_set_presentation(u_int32_t arg0, struct rk_text_info * arg1)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_rk_text_info(arg1);
	fnum = 37;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_rk_text_info(arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_delete_text(u_int32_t arg0)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	fnum = 38;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

void 
rk_sync(void)
{
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	fnum = 39;
	buf_start = NULL;
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);
}

int32_t 
rk_create_conf(char * arg0, u_int32_t arg1)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_string(&arg0);
	msglen += get_size_encoded_u_int32_t(&arg1);
	fnum = 40;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_string(&arg0, &enc_buf);
	encode_u_int32_t(&arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_delete_conf(u_int32_t arg0)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	fnum = 41;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_create_person(char * arg0, char * arg1, u_int32_t arg2)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_string(&arg0);
	msglen += get_size_encoded_string(&arg1);
	msglen += get_size_encoded_u_int32_t(&arg2);
	fnum = 42;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_string(&arg0, &enc_buf);
	encode_string(&arg1, &enc_buf);
	encode_u_int32_t(&arg2, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_set_motd(u_int32_t arg0, struct rk_text_info * arg1)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_rk_text_info(arg1);
	fnum = 43;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_rk_text_info(arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_add_text_info(u_int32_t arg0, struct rk_aux_item_input * arg1)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_u_int32_t(&arg0);
	msglen += get_size_encoded_rk_aux_item_input(arg1);
	fnum = 44;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_u_int32_t(&arg0, &enc_buf);
	encode_rk_aux_item_input(arg1, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}

int32_t 
rk_modify_conf_info(struct rk_modifyconfinfo * arg0)
{
	int32_t ret_val;
	u_int32_t	msglen, fnum;
	char		*buf_start, *dyn_buf;
	char		*enc_buf;
	size_t		d_len, s_len;

	msglen = 0;
	dyn_buf = dyn_buf; /* silent gcc */
	msglen += get_size_encoded_rk_modifyconfinfo(arg0);
	fnum = 45;
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;
	encode_rk_modifyconfinfo(arg0, &enc_buf);
	spc_write_fun_call(fnum, buf_start, msglen);
	free(buf_start);

	msglen = spc_read_msglen();
	if ((buf_start = malloc(msglen)) == NULL)
		err(1, "malloc");
	enc_buf = buf_start;

	spc_read_msg(enc_buf, msglen);
	enc_buf = buf_start;
	decode_int32_t(&ret_val, NULL, &enc_buf, &d_len, &s_len);
	assert(d_len == 0);
	free(buf_start);
	return ret_val;
}



/* Implementation of server functions */

void
spc_process_request(void)
{
	size_t		d_len, s_len, dyn_len, enc_len;
	u_int32_t	fnum, msglen;
	char		*enc_buf, *enc_start, *dyn_mem;

	msglen = spc_read_msglen();
	fnum = spc_read_fun_num();
	msglen -= sizeof(fnum);
	if ((enc_start = alloca(msglen)) == NULL)
		err(1, "alloca");
	enc_buf = enc_start;
	spc_read_msg(enc_buf, msglen);

	switch(fnum) {
	case 0: {
		char *arg0;
		char *arg1;
		char *arg2;
		char *arg3;
		struct rk_server *ret_val;

		dyn_len = 0;
		get_size_decoded_string(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_string(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_string(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_string(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_string(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_string(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_string(&arg2, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_string(&arg3, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_connect_server(arg0, arg1, arg2, arg3);
		enc_len = get_size_encoded_rk_server(ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_rk_server(ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 1: {
		u_int32_t arg0;
		char *arg1;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_string(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_string(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_login_server(arg0, arg1);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 2: {
		char *arg0;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_string(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_string(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_whatido_server(arg0);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 3: {
		u_int32_t arg0;
		struct rk_unreadconfval *ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_unreadconf_server(arg0);
		enc_len = get_size_encoded_rk_unreadconfval(ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_rk_unreadconfval(ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 4: {
		u_int32_t arg0;
		struct rk_memberconflist *ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_memberconf_server(arg0);
		enc_len = get_size_encoded_rk_memberconflist(ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_rk_memberconflist(ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 5: {
		char *arg0;
		u_int8_t arg1;
		struct rk_confinfo_retval *ret_val;

		dyn_len = 0;
		get_size_decoded_string(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int8_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_string(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int8_t(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_matchconf_server(arg0, arg1);
		enc_len = get_size_encoded_rk_confinfo_retval(ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_rk_confinfo_retval(ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 6: {
		u_int32_t arg0;
		struct rk_uconference *ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_uconfinfo_server(arg0);
		enc_len = get_size_encoded_rk_uconference(ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_rk_uconference(ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 7: {
		u_int32_t arg0;
		struct rk_conference *ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_confinfo_server(arg0);
		enc_len = get_size_encoded_rk_conference(ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_rk_conference(ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 8: {
		u_int32_t arg0;
		struct rk_person *ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_persinfo_server(arg0);
		enc_len = get_size_encoded_rk_person(ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_rk_person(ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 9: {
		dyn_len = 0;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		rk_alive_server();
		break;
	}
	case 10: {
		u_int32_t arg0;
		u_int32_t arg1;
		struct rk_membership *ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int32_t(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_membership_server(arg0, arg1);
		enc_len = get_size_encoded_rk_membership(ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_rk_membership(ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 11: {
		u_int32_t arg0;
		u_int32_t arg1;
		struct rk_dynamic_session_info_retval *ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int32_t(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_vilka_server(arg0, arg1);
		enc_len = get_size_encoded_rk_dynamic_session_info_retval(ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_rk_dynamic_session_info_retval(ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 12: {
		u_int32_t arg0;
		char *ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_client_version_server(arg0);
		enc_len = get_size_encoded_string(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_string(&ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 13: {
		u_int32_t arg0;
		char *ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_client_name_server(arg0);
		enc_len = get_size_encoded_string(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_string(&ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 14: {
		struct rk_time *ret_val;

		dyn_len = 0;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		ret_val = rk_time_server();
		enc_len = get_size_encoded_rk_time(ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_rk_time(ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 15: {
		u_int32_t arg0;
		u_int32_t arg1;
		u_int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int32_t(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_next_unread_server(arg0, arg1);
		enc_len = get_size_encoded_u_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_u_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 16: {
		u_int32_t arg0;
		u_int32_t arg1;
		u_int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int32_t(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_local_to_global_server(arg0, arg1);
		enc_len = get_size_encoded_u_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_u_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 17: {
		u_int32_t arg0;
		u_int32_t arg1;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int32_t(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_mark_read_server(arg0, arg1);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 18: {
		u_int32_t arg0;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_is_read_server(arg0);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 19: {
		u_int32_t arg0;
		struct rk_text_stat *ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_textstat_server(arg0);
		enc_len = get_size_encoded_rk_text_stat(ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_rk_text_stat(ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 20: {
		u_int32_t arg0;
		char *ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_gettext_server(arg0);
		enc_len = get_size_encoded_string(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_string(&ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 21: {
		u_int32_t arg0;
		u_int32_t arg1;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int32_t(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_set_last_read_server(arg0, arg1);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 22: {
		u_int32_t arg0;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_change_conference_server(arg0);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 23: {
		u_int32_t arg0;
		u_int32_t arg1;
		u_int8_t arg2;
		u_int16_t arg3;
		u_int32_t arg4;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int8_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int16_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int32_t(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int8_t(&arg2, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int16_t(&arg3, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int32_t(&arg4, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_add_member_server(arg0, arg1, arg2, arg3, arg4);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 24: {
		u_int32_t arg0;
		u_int32_t arg1;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int32_t(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_sub_member_server(arg0, arg1);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 25: {
		u_int32_t arg0;
		u_int32_t arg1;
		u_int32_t arg2;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int32_t(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int32_t(&arg2, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_add_rcpt_server(arg0, arg1, arg2);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 26: {
		u_int32_t arg0;
		u_int32_t arg1;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int32_t(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_sub_rcpt_server(arg0, arg1);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 27: {
		struct rk_text_info arg0;
		struct rk_text_retval *ret_val;

		dyn_len = 0;
		get_size_decoded_rk_text_info(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_rk_text_info(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_create_text_server(&arg0);
		enc_len = get_size_encoded_rk_text_retval(ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_rk_text_retval(ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 28: {
		struct rk_async *ret_val;

		dyn_len = 0;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		ret_val = rk_async_server();
		enc_len = get_size_encoded_rk_async(ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_rk_async(ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 29: {
		u_int32_t arg0;
		char *arg1;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_string(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_string(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_send_msg_server(arg0, arg1);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 30: {
		struct rk_mark_retval *ret_val;

		dyn_len = 0;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		ret_val = rk_getmarks_server();
		enc_len = get_size_encoded_rk_mark_retval(ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_rk_mark_retval(ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 31: {
		u_int32_t arg0;
		u_int8_t arg1;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int8_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int8_t(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_setmark_server(arg0, arg1);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 32: {
		u_int32_t arg0;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_unmark_server(arg0);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 33: {
		char *arg0;
		struct rk_uarea *ret_val;

		dyn_len = 0;
		get_size_decoded_string(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_string(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_get_uarea_server(arg0);
		enc_len = get_size_encoded_rk_uarea(ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_rk_uarea(ret_val, &enc_buf);
		free(ret_val);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 34: {
		char *arg0;
		struct rk_uarea arg1;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_string(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_rk_uarea(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_string(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_rk_uarea(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_set_uarea_server(arg0, &arg1);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 35: {
		u_int32_t arg0;
		char *arg1;
		char *arg2;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_string(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_string(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_string(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_string(&arg2, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_setpass_server(arg0, arg1, arg2);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 36: {
		u_int32_t arg0;
		char *arg1;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_string(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_string(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_change_name_server(arg0, arg1);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 37: {
		u_int32_t arg0;
		struct rk_text_info arg1;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_rk_text_info(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_rk_text_info(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_set_presentation_server(arg0, &arg1);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 38: {
		u_int32_t arg0;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_delete_text_server(arg0);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 39: {
		dyn_len = 0;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		rk_sync_server();
		break;
	}
	case 40: {
		char *arg0;
		u_int32_t arg1;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_string(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_string(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int32_t(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_create_conf_server(arg0, arg1);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 41: {
		u_int32_t arg0;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_delete_conf_server(arg0);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 42: {
		char *arg0;
		char *arg1;
		u_int32_t arg2;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_string(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_string(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_string(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_string(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_u_int32_t(&arg2, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_create_person_server(arg0, arg1, arg2);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 43: {
		u_int32_t arg0;
		struct rk_text_info arg1;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_rk_text_info(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_rk_text_info(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_set_motd_server(arg0, &arg1);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 44: {
		u_int32_t arg0;
		struct rk_aux_item_input arg1;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_u_int32_t(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		get_size_decoded_rk_aux_item_input(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_u_int32_t(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		decode_rk_aux_item_input(&arg1, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_add_text_info_server(arg0, &arg1);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}
	case 45: {
		struct rk_modifyconfinfo arg0;
		int32_t ret_val;

		dyn_len = 0;
		get_size_decoded_rk_modifyconfinfo(&enc_buf, &d_len, &s_len);
		dyn_len += d_len;
		if ((dyn_mem = alloca(dyn_len)) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		decode_rk_modifyconfinfo(&arg0, &dyn_mem, &enc_buf, &d_len, &s_len);
		ret_val = rk_modify_conf_info_server(&arg0);
		enc_len = get_size_encoded_int32_t(&ret_val);
		if ((enc_start = alloca(enc_len + sizeof(msglen))) == NULL)
			err(1, "alloca");
		enc_buf = enc_start;
		msglen = enc_len;
		encode_int32_t(&ret_val, &enc_buf);
		enc_buf = enc_start;
		spc_write_msg(enc_buf, enc_len);
		break;
	}

	}
}

